#include <stddef.h>
#include <stdint.h>
#include <string.h>

#include "multiformats/multibase/multibase.h"

/* Determine system endianness */
#if defined(__BYTE_ORDER__) && (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
#define BIG_ENDIAN_SYSTEM 1
#else
#define BIG_ENDIAN_SYSTEM 0
#endif

/* Little‑endian lookup table */
static const uint16_t hex_lookup_le[256] = 
{
    0x3030, 0x3130, 0x3230, 0x3330, 0x3430, 0x3530, 0x3630, 0x3730, 0x3830, 0x3930, 0x6130, 0x6230, 0x6330, 0x6430, 0x6530, 0x6630, 0x3031, 0x3131,
    0x3231, 0x3331, 0x3431, 0x3531, 0x3631, 0x3731, 0x3831, 0x3931, 0x6131, 0x6231, 0x6331, 0x6431, 0x6531, 0x6631, 0x3032, 0x3132, 0x3232, 0x3332,
    0x3432, 0x3532, 0x3632, 0x3732, 0x3832, 0x3932, 0x6132, 0x6232, 0x6332, 0x6432, 0x6532, 0x6632, 0x3033, 0x3133, 0x3233, 0x3333, 0x3433, 0x3533,
    0x3633, 0x3733, 0x3833, 0x3933, 0x6133, 0x6233, 0x6333, 0x6433, 0x6533, 0x6633, 0x3034, 0x3134, 0x3234, 0x3334, 0x3434, 0x3534, 0x3634, 0x3734,
    0x3834, 0x3934, 0x6134, 0x6234, 0x6334, 0x6434, 0x6534, 0x6634, 0x3035, 0x3135, 0x3235, 0x3335, 0x3435, 0x3535, 0x3635, 0x3735, 0x3835, 0x3935,
    0x6135, 0x6235, 0x6335, 0x6435, 0x6535, 0x6635, 0x3036, 0x3136, 0x3236, 0x3336, 0x3436, 0x3536, 0x3636, 0x3736, 0x3836, 0x3936, 0x6136, 0x6236,
    0x6336, 0x6436, 0x6536, 0x6636, 0x3037, 0x3137, 0x3237, 0x3337, 0x3437, 0x3537, 0x3637, 0x3737, 0x3837, 0x3937, 0x6137, 0x6237, 0x6337, 0x6437,
    0x6537, 0x6637, 0x3038, 0x3138, 0x3238, 0x3338, 0x3438, 0x3538, 0x3638, 0x3738, 0x3838, 0x3938, 0x6138, 0x6238, 0x6338, 0x6438, 0x6538, 0x6638,
    0x3039, 0x3139, 0x3239, 0x3339, 0x3439, 0x3539, 0x3639, 0x3739, 0x3839, 0x3939, 0x6139, 0x6239, 0x6339, 0x6439, 0x6539, 0x6639, 0x3061, 0x3161,
    0x3261, 0x3361, 0x3461, 0x3561, 0x3661, 0x3761, 0x3861, 0x3961, 0x6161, 0x6261, 0x6361, 0x6461, 0x6561, 0x6661, 0x3062, 0x3162, 0x3262, 0x3362,
    0x3462, 0x3562, 0x3662, 0x3762, 0x3862, 0x3962, 0x6162, 0x6262, 0x6362, 0x6462, 0x6562, 0x6662, 0x3063, 0x3163, 0x3263, 0x3363, 0x3463, 0x3563,
    0x3663, 0x3763, 0x3863, 0x3963, 0x6163, 0x6263, 0x6363, 0x6463, 0x6563, 0x6663, 0x3064, 0x3164, 0x3264, 0x3364, 0x3464, 0x3564, 0x3664, 0x3764,
    0x3864, 0x3964, 0x6164, 0x6264, 0x6364, 0x6464, 0x6564, 0x6664, 0x3065, 0x3165, 0x3265, 0x3365, 0x3465, 0x3565, 0x3665, 0x3765, 0x3865, 0x3965,
    0x6165, 0x6265, 0x6365, 0x6465, 0x6565, 0x6665, 0x3066, 0x3166, 0x3266, 0x3366, 0x3466, 0x3566, 0x3666, 0x3766, 0x3866, 0x3966, 0x6166, 0x6266,
    0x6366, 0x6466, 0x6566, 0x6666
};

/* Big‑endian lookup table */
static const uint16_t hex_lookup_be[256] = 
{
    0x3030, 0x3031, 0x3032, 0x3033, 0x3034, 0x3035, 0x3036, 0x3037, 0x3038, 0x3039, 0x3061, 0x3062, 0x3063, 0x3064, 0x3065, 0x3066, 0x3130, 0x3131,
    0x3132, 0x3133, 0x3134, 0x3135, 0x3136, 0x3137, 0x3138, 0x3139, 0x3161, 0x3162, 0x3163, 0x3164, 0x3165, 0x3166, 0x3230, 0x3231, 0x3232, 0x3233,
    0x3234, 0x3235, 0x3236, 0x3237, 0x3238, 0x3239, 0x3261, 0x3262, 0x3263, 0x3264, 0x3265, 0x3266, 0x3330, 0x3331, 0x3332, 0x3333, 0x3334, 0x3335,
    0x3336, 0x3337, 0x3338, 0x3339, 0x3361, 0x3362, 0x3363, 0x3364, 0x3365, 0x3366, 0x3430, 0x3431, 0x3432, 0x3433, 0x3434, 0x3435, 0x3436, 0x3437,
    0x3438, 0x3439, 0x3461, 0x3462, 0x3463, 0x3464, 0x3465, 0x3466, 0x3530, 0x3531, 0x3532, 0x3533, 0x3534, 0x3535, 0x3536, 0x3537, 0x3538, 0x3539,
    0x3561, 0x3562, 0x3563, 0x3564, 0x3565, 0x3566, 0x3630, 0x3631, 0x3632, 0x3633, 0x3634, 0x3635, 0x3636, 0x3637, 0x3638, 0x3639, 0x3661, 0x3662,
    0x3663, 0x3664, 0x3665, 0x3666, 0x3730, 0x3731, 0x3732, 0x3733, 0x3734, 0x3735, 0x3736, 0x3737, 0x3738, 0x3739, 0x3761, 0x3762, 0x3763, 0x3764,
    0x3765, 0x3766, 0x3830, 0x3831, 0x3832, 0x3833, 0x3834, 0x3835, 0x3836, 0x3837, 0x3838, 0x3839, 0x3861, 0x3862, 0x3863, 0x3864, 0x3865, 0x3866,
    0x3930, 0x3931, 0x3932, 0x3933, 0x3934, 0x3935, 0x3936, 0x3937, 0x3938, 0x3939, 0x3961, 0x3962, 0x3963, 0x3964, 0x3965, 0x3966, 0x6130, 0x6131,
    0x6132, 0x6133, 0x6134, 0x6135, 0x6136, 0x6137, 0x6138, 0x6139, 0x6161, 0x6162, 0x6163, 0x6164, 0x6165, 0x6166, 0x6230, 0x6231, 0x6232, 0x6233,
    0x6234, 0x6235, 0x6236, 0x6237, 0x6238, 0x6239, 0x6261, 0x6262, 0x6263, 0x6264, 0x6265, 0x6266, 0x6330, 0x6331, 0x6332, 0x6333, 0x6334, 0x6335,
    0x6336, 0x6337, 0x6338, 0x6339, 0x6361, 0x6362, 0x6363, 0x6364, 0x6365, 0x6366, 0x6430, 0x6431, 0x6432, 0x6433, 0x6434, 0x6435, 0x6436, 0x6437,
    0x6438, 0x6439, 0x6461, 0x6462, 0x6463, 0x6464, 0x6465, 0x6466, 0x6530, 0x6531, 0x6532, 0x6533, 0x6534, 0x6535, 0x6536, 0x6537, 0x6538, 0x6539,
    0x6561, 0x6562, 0x6563, 0x6564, 0x6565, 0x6566, 0x6630, 0x6631, 0x6632, 0x6633, 0x6634, 0x6635, 0x6636, 0x6637, 0x6638, 0x6639, 0x6661, 0x6662,
    0x6663, 0x6664, 0x6665, 0x6666
};

/* The decoding lookup table accepts only valid lowercase hex digits:
 *  - '0'–'9' (ASCII 0x30–0x39) are mapped to 0x00–0x09.
 *  - 'a'–'f' (ASCII 0x61–0x66) are mapped to 0x0A–0x0F.
 * All other characters are marked as invalid (0x80).
 */
static const uint8_t hex_values_table[256] = 
{
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
    0x80, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80
};

/* Select the proper lookup table */
#define HEX_LOOKUP (BIG_ENDIAN_SYSTEM ? hex_lookup_be : hex_lookup_le)

/**
 * @brief Encode data into Base16 (hexadecimal) format using lowercase letters.
 *
 * @param data     The input data to be encoded.
 * @param data_len The length of the input data.
 * @param out      The buffer to store the encoded Base16 string.
 * @param out_len  The size of the output buffer (must include space for NUL).
 * @return Number of characters in the output (excluding the NUL),
 *         or an error code.
 */
int multibase_base16_encode(const uint8_t *restrict data, size_t data_len, char *restrict out, size_t out_len)
{
    if (data == NULL || out == NULL)
    {
        return MULTIBASE_ERR_NULL_POINTER;
    }

#ifdef REQUIRE_STRICT_ALIGNMENT
#define HEX_ALIGNMENT (sizeof(uint32_t))
#else
#define HEX_ALIGNMENT (sizeof(uint16_t))
#endif

    if ((((uintptr_t)out) & (HEX_ALIGNMENT - 1)) == 0)
    {
#ifdef REQUIRE_STRICT_ALIGNMENT
        if (out_len < data_len * 2 + 2)
        {
            return MULTIBASE_ERR_BUFFER_TOO_SMALL;
        }
#else
        if (out_len < data_len * 2 + 1)
        {
            return MULTIBASE_ERR_BUFFER_TOO_SMALL;
        }
#endif
        uint16_t *restrict out16 = (uint16_t *)out;
        for (size_t i = 0; i < data_len; i++)
        {
            out16[i] = HEX_LOOKUP[data[i]];
        }
#ifdef REQUIRE_STRICT_ALIGNMENT
        out16[data_len] = 0;
#else
        out16[data_len] = 0;
#endif
    }
    else
    {
        if (out_len < data_len * 2 + 1)
        {
            return MULTIBASE_ERR_BUFFER_TOO_SMALL;
        }
        for (size_t i = 0; i < data_len; i++)
        {
            uint16_t val = HEX_LOOKUP[data[i]];
            if (BIG_ENDIAN_SYSTEM)
            {
                out[2 * i] = (char)(val >> 8);
                out[2 * i + 1] = (char)(val & 0xFF);
            }
            else
            {
                out[2 * i] = (char)(val & 0xFF);
                out[2 * i + 1] = (char)(val >> 8);
            }
        }
        out[data_len * 2] = '\0';
    }
    return (int)(data_len * 2);
}

/**
 * @brief Decode a Base16 (hexadecimal) encoded string using lowercase letters.
 *
 * @param in       The input Base16 encoded string.
 * @param data_len The length of the input string (must be multiple of 2).
 * @param out      The buffer to store the decoded bytes.
 * @param out_len  The size of the output buffer (in bytes).
 * @return Number of decoded bytes, or an error code.
 *
 * @note
 * This table-based decoder only accepts lowercase 'a'–'f' for 10–15
 * and rejects uppercase 'A'–'F'. Adjust if you want uppercase acceptance.
 */
int multibase_base16_decode(const char *restrict in, size_t data_len, uint8_t *restrict out, size_t out_len)
{
    if (in == NULL || out == NULL)
    {
        return MULTIBASE_ERR_NULL_POINTER;
    }
    if ((data_len & 1) != 0)
    {
        return MULTIBASE_ERR_INVALID_INPUT_LEN;
    }

    size_t required_out_len = data_len / 2;
    if (out_len < required_out_len)
    {
        return MULTIBASE_ERR_BUFFER_TOO_SMALL;
    }

    const unsigned char *in_ptr = (const unsigned char *)in;
    uint8_t *out_ptr = out;
    size_t i = 0;
    size_t bulk_end = required_out_len - (required_out_len % 8);

    while (i < bulk_end)
    {
        uint8_t v0 = hex_values_table[in_ptr[0]];
        uint8_t v1 = hex_values_table[in_ptr[1]];
        uint8_t v2 = hex_values_table[in_ptr[2]];
        uint8_t v3 = hex_values_table[in_ptr[3]];
        uint8_t v4 = hex_values_table[in_ptr[4]];
        uint8_t v5 = hex_values_table[in_ptr[5]];
        uint8_t v6 = hex_values_table[in_ptr[6]];
        uint8_t v7 = hex_values_table[in_ptr[7]];
        uint8_t v8 = hex_values_table[in_ptr[8]];
        uint8_t v9 = hex_values_table[in_ptr[9]];
        uint8_t v10 = hex_values_table[in_ptr[10]];
        uint8_t v11 = hex_values_table[in_ptr[11]];
        uint8_t v12 = hex_values_table[in_ptr[12]];
        uint8_t v13 = hex_values_table[in_ptr[13]];
        uint8_t v14 = hex_values_table[in_ptr[14]];
        uint8_t v15 = hex_values_table[in_ptr[15]];

        if ((v0 | v1 | v2 | v3 | v4 | v5 | v6 | v7 | v8 | v9 | v10 | v11 | v12 | v13 | v14 | v15) & 0x80)
        {
            return MULTIBASE_ERR_INVALID_CHARACTER;
        }

        out_ptr[0] = (uint8_t)((v0 << 4) | v1);
        out_ptr[1] = (uint8_t)((v2 << 4) | v3);
        out_ptr[2] = (uint8_t)((v4 << 4) | v5);
        out_ptr[3] = (uint8_t)((v6 << 4) | v7);
        out_ptr[4] = (uint8_t)((v8 << 4) | v9);
        out_ptr[5] = (uint8_t)((v10 << 4) | v11);
        out_ptr[6] = (uint8_t)((v12 << 4) | v13);
        out_ptr[7] = (uint8_t)((v14 << 4) | v15);

        in_ptr += 16;
        out_ptr += 8;
        i += 8;
    }

    while (i < required_out_len)
    {
        uint8_t hi = hex_values_table[in_ptr[0]];
        uint8_t lo = hex_values_table[in_ptr[1]];

        if ((hi | lo) & 0x80)
        {
            return MULTIBASE_ERR_INVALID_CHARACTER;
        }
        *out_ptr++ = (uint8_t)((hi << 4) | lo);
        in_ptr += 2;
        i++;
    }

    return (int)required_out_len;
}